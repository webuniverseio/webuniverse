<!doctype html> <html lang="en" class="no-js"> <head prefix="og: http://ogp.me/ns# fb: http://ogp.me/ns/fb# article: http://ogp.me/ns/article#"> <meta http-equiv="x-dns-prefetch-control" content="on"> <link rel="dns-prefetch" href="//webuniverse.disqus.com"> <link rel="dns-prefetch" href="//a.disquscdn.com"> <link rel="dns-prefetch" href="//disqus.com"> <link rel="dns-prefetch" href="//glitter-services.disqus.com"> <link rel="dns-prefetch" href="//referrer.disqus.com"> <meta name="twitter:card" content="summary"> <meta name="twitter:site" content="@webuniverseio"> <meta property="og:url" content="http://webuniverse.io/asynchronous-programming-with-ES6-generators-promises-and-npm-co/index.html"> <meta name="twitter:url" content="http://webuniverse.io/asynchronous-programming-with-ES6-generators-promises-and-npm-co/index.html"> <meta property="og:title" content="Asynchronous programming with ES6 generators, promises and npm-co | Web Universe"> <meta name="twitter:title" content="Asynchronous programming with ES6 generators, promises and npm-co | Web Universe"> <meta property="og:site_name" content="Web Universe"> <meta property="og:type" content="article"> <meta property="article:publisher" content="https://www.facebook.com/webuniverseio"> <meta property="article:published_time" content="2015-02-03T18:20:00-05:00"> <meta name="description" content="Simplify your code by writing an asynchronous code in a synchronous manner"> <meta property="og:description" content="Simplify your code by writing an asynchronous code in a synchronous manner"> <meta name="twitter:description" content="Simplify your code by writing an asynchronous code in a synchronous manner"> <meta property="og:image" content="http://webuniverse.io/asynchronous-programming-with-ES6-generators-promises-and-npm-co/image.v1.jpg"> <meta name="twitter:image" content="http://webuniverse.io/asynchronous-programming-with-ES6-generators-promises-and-npm-co/image.v1.jpg"> <meta name="viewport" content="width=device-width,initial-scale=1"> <meta name="format-detection" content="telephone=no"> <meta charset="utf-8"> <!--[if lte IE 8]><meta http-equiv="refresh" content="0;URL='https://browser-update.org/update.html'" /><![endif]--> <title>Asynchronous programming with ES6 generators, promises and npm-co | Web Universe</title> <script>document.documentElement.className=document.documentElement.className.replace("no-js",""),document.createElement("picture");</script><link rel="canonical" href="http://webuniverse.io/asynchronous-programming-with-ES6-generators-promises-and-npm-co/index.html"> <link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png"> <link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png"> <link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png"> <link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png"> <link rel="apple-touch-icon" sizes="60x60" href="/apple-touch-icon-60x60.png"> <link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png"> <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png"> <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png"> <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png"> <link rel="icon" type="image/png" href="/favicon-192x192.png" sizes="192x192"> <link rel="icon" type="image/png" href="/favicon-160x160.png" sizes="160x160"> <link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96"> <link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16"> <link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32"> <meta name="msapplication-TileColor" content="#2b5797"> <meta name="msapplication-TileImage" content="/mstile-144x144.png"> <link rel="alternative" href="/atom.xml" title="Web Universe" type="application/atom+xml"> <link rel="stylesheet" href="/static/dest/css/main.v1.1.2.css"> </head></html> <body itemscope itemtype="http://schema.org/WebPage"> <meta itemprop="typicalAgeRange" content="17-"> <div id="page__wrapper"> <div id="page__layout-base"> <header id="page__header" role="banner"> <a href="/"> <h1 class="logo" itemprop="name"> Web <span class="logo__universe">Universe</span> </h1> </a> </header> <div id="page-content__wrapper"> <div id="page-content"> <div id="top-bar" class="ov-h"> <nav class="navigation decorate-links-on-hover column" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation"> <h2 class="a11y__element">Main navigation</h2> <a href="#page-content__main" class="a11y__skip navigation__skip">skip navigation</a> <a href="/" itemprop="url"> <span itemprop="name">Home</span></a> <span class="navigation__separator"></span> <a href="/about/" itemprop="url"> <span itemprop="name">About</span></a> <span class="navigation__separator"></span> <a href="/projects/" itemprop="url"> <span itemprop="name">Projects</span></a> <span class="navigation__separator"></span> <a href="/recommended/" itemprop="url"> <span itemprop="name">Recommended</span></a> <span class="navigation__separator"></span> <a href="/contact/" itemprop="url"> <span itemprop="name">Contact</span></a> </nav> <div class="column"> <section> <h3 class="a11y__element">Search panel</h3> <div class="gcse-search" style="height:33px"></div> </section> </div> </div> <main id="page-content__main" tabindex="0" class="page-content__side-padding ov-h"> <div class="article" itemscope itemtype="http://schema.org/Article" id="post-asynchronous-programming-with-ES6-generators-promises-and-npm-co" class="article"> <article class="content-entry" itemprop="articleBody"> <div class="article__image-wrapper"> <picture> <!--[if IE 9]><video style="display: none;"><![endif]--> <source srcset="image.v1.jpg" media="(min-width: 600px)"> <!--[if IE 9]></video><![endif]--> <img srcset="imageSmall.jpg" alt="Asynchronous programming with ES6 generators, promises and npm-co"> </source></picture> </div> <h1 itemprop="name" class="article__title">Asynchronous programming with ES6 generators, promises and npm-co</h1> <time class="datetime" datetime="2015-02-03T23:20:00.000Z" itemprop="datePublished"> 03 February, 2015 </time> <meta itemprop="datePublished" content="2011-05-08T19:30"> <p>This article explains what an npm <code>co</code> module is, how it works and how it can help you to write much cleaner and simpler asynchronous code.</p> <h2 id="The_problem">The problem</h2><p>Writing asynchronous code could be very tricky, if you never did it before or didn’t learn or develop good patterns to approach it. Asynchronous programming in javascript became popular with arrival of single page applications and node.js (where most of the operations happen asynchronously by default). Traditionally javascript was handling async operations using callbacks, and at least once every web developer faced a problem called <a href="https://www.google.ca/search?q=callback+hell+definition&amp;tbm=isch" target="_blank" rel="external"><code>callback hell</code></a> or <code>pyramid of doom</code>.</p> <h2 id="Solutions">Solutions</h2><p>A simple solution is to keep your code shallow, though error handling wouldn’t be that simple. Another one, very well established solution is to use promises. Using ES6 generators we can simplify code for promises and continue writing code in a synchronous, easy to follow, manner, while keeping it asynchronous. If you’re not familiar with how <a href="#promises">promises</a> or <a href="#generators">generators</a> are working, please do a quick research before you continue reading.</p> <h3 id="co_to_the_rescue">co to the rescue</h3><p>co is a wrapper around promises and generators which allows to simplify asynchronous code a lot. Take a look at the example which shows how an async code could be written in a sync manner using co:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">co(<span class="function"><span class="keyword">function</span>* <span class="title">getResults</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//assume read and request perform asynchronous actions</span></span><br><span class="line">  <span class="keyword">var</span> a = read(<span class="string">'index.js'</span>, <span class="string">'utf8'</span>);</span><br><span class="line">  <span class="keyword">var</span> b = request(<span class="string">'http://google.ca'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//when all operations will finish </span></span><br><span class="line">  <span class="comment">//res will have contents of index.js at [0]</span></span><br><span class="line">  <span class="comment">//and response body from google at [1]</span></span><br><span class="line">  <span class="keyword">var</span> res = <span class="keyword">yield</span> [a, b];</span><br><span class="line">  <span class="comment">//...code which does something with res</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> <span class="params">(ex)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//if an error was thrown from read or request functions</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p> <p>Here is what co will do for us:</p> <ul> <li>Both read and request will execute in parallel on line 7 and when both of them finish - res array will hold results. It doesn’t matter if request finishes before read - co will ensure that results are assigned to appropriate indexes.</li> <li>On node.js you would have to check for errors in both callbacks for read and request functions, to ensure that your application does not exit in an unhandled state, but with co we can only worry about an end result and add a single error handler using <code>.catch</code>.</li> <li>Code is rather short and easy to understand</li> </ul> <p>So what exactly is happening? How does it work? To understand it better lets go over code of the main function in co and describe it. <a href="https://github.com/tj/co/blob/48ca4dcfa6b6a7396aef57e8d78928cfffc814bc/index.js#L41" target="_blank" rel="external">Open</a> code in new window so that you can put it side by side.</p> <p>Let`s modify example just a little, in order to show how various scenarios will work in co:<br><figure class="highlight js"><figcaption><span>example.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">co(<span class="function"><span class="keyword">function</span>* <span class="title">getResults</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//not really doing anything important,</span></span><br><span class="line">  <span class="comment">//but will be useful to show how co works</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(ex.message);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//assume read and request perform asynchronous actions</span></span><br><span class="line">  <span class="keyword">var</span> a = read(<span class="string">'index.js'</span>, <span class="string">'utf8'</span>);</span><br><span class="line">  <span class="keyword">var</span> b = request(<span class="string">'http://google.ca'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//when all operations will finish </span></span><br><span class="line">  <span class="comment">//res will have contents of index.js at [0]</span></span><br><span class="line">  <span class="comment">//and response body from google at [1]</span></span><br><span class="line">  <span class="keyword">var</span> res = <span class="keyword">yield</span> [a, b];</span><br><span class="line">  <span class="comment">//...code, which does something with res</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> <span class="params">(ex)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//if an error was thrown from read or request functions</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p> <p>First co saves context reference, in case you will ever want to use a context inside read or request functions:<br><figure class="highlight js"><figcaption><span>co/index.js:co</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ctx = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Context binding example</span></span><br><span class="line">co.call(context, <span class="function"><span class="keyword">function</span>* <span class="title">getResults</span><span class="params">()</span> </span>&#123;<span class="comment">/*'this' will point to context*/</span>&#125;)</span><br></pre></td></tr></table></figure></p> <p>Then it checks, if <code>gen</code> is a function. If it is, then co needs to initialize a generator object by calling a function and it also ensure that <code>this</code> has a proper context. If <code>gen</code> is already a generator object, a statement will be skipped:<br><figure class="highlight js"><figcaption><span>co/index.js:co</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> gen === <span class="string">'function'</span>) gen = gen.call(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure></p> <p>Then co returns a new Promise and runs <code>onFulfilled</code> function with no arguments. Inside that function it will try to execute a generator code until a first <code>yield</code> statement.<br><figure class="highlight js"><figcaption><span>co/index.js:onFulfilled</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ret;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  ret = gen.next(res); <span class="comment">//res is undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p> <p>In our case following code would execute inside <code>getResults</code> generator:<br><figure class="highlight js"><figcaption><span>example.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p> <p>If that code could throw an error - promise would be rejected with an error object and co would exit.<br><figure class="highlight js"><figcaption><span>co/index.js:onFulfilled</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="keyword">return</span> reject(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p> <p>In our case generator returns an object with a <code>value</code> property containing yielded value and this object is assigned to <code>ret</code>. At that moment of time code would look like that:<br><figure class="highlight js"><figcaption><span>co/index.js:onFulfilled</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ret;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  ret = &#123;value: <span class="literal">false</span>, done: <span class="literal">false</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p> <p>Then <code>onFulfilled</code> will call <code>next(ret);</code>. If <code>done</code> would be true, co would resolve a promise with the value and exit from next:<br><figure class="highlight js"><figcaption><span>co/index.js:next</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ret.done) <span class="keyword">return</span> resolve(ret.value);</span><br></pre></td></tr></table></figure></p> <p>Otherwise co attempts to convert <code>ret.value</code> to a promise (we’ll skip <code>toPromise</code> for now). <code>.call</code> is there to provide original context in case <code>ret.value</code> is another <a href="https://github.com/tj/co#yieldables" target="_blank" rel="external">yieldable</a> value:<br><figure class="highlight js"><figcaption><span>co/index.js:next</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = toPromise.call(ctx, ret.value);</span><br></pre></td></tr></table></figure></p> <p>On next line co checks if value is not falsy and if it is a promise, and if so, it adds appropriate handlers for promise fulfilment or rejection and exits from next.<br><figure class="highlight js"><figcaption><span>co/index.js:next</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (value &amp;&amp; isPromise(value)) <span class="keyword">return</span> value.then(onFulfilled, onRejected);</span><br></pre></td></tr></table></figure></p> <p>Notice how <code>onFulfilled</code>, <code>onRejected</code> and <code>next</code> functions have references to <code>resolve</code> and <code>reject</code> callbacks from a new Promise, which was created at the beginning. If one of these functions calls <code>resolve</code> or <code>reject</code>, then top most promise will be settled. </p> <p>In our case <code>ret.value</code> in our case is <code>false</code>, so next calls <code>onRejected</code> handler, passes it a new TypeError and exits.<br><figure class="highlight js"><figcaption><span>co/index.js:next</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> onRejected(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'You may only yield a function, promise, generator, array, or object, '</span></span><br><span class="line">        + <span class="string">'but the following object was passed: "'</span> + <span class="built_in">String</span>(ret.value) + <span class="string">'"'</span>));</span><br></pre></td></tr></table></figure></p> <p><code>onRejected</code> is working quite similar to <code>onFulfilled</code> function with the following difference - instead of running a code until next <code>yield</code> statement, it tries to throw an error inside generator function <em>at the place where it stopped before</em>:<br><figure class="highlight js"><figcaption><span>co/index.js:onRejected</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ret;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  ret = gen.throw(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p> <p>That means it will replace <code>yield false</code> with <code>throw err</code> and example would look like this:<br><figure class="highlight js"><figcaption><span>example.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> err; <span class="comment">//err is a TypeError</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(ex.message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p> <p>That behaviour is completely normal for generators and is described on MDN:<br><blockquote><p>You can force a generator to throw an exception by calling its throw() method and passing the exception value it should throw. This exception will be thrown from the current suspended context of the generator, as if the yield that is currently suspended were instead a throw value statement.</p> <footer><strong>MDN</strong><cite><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators" target="_blank" rel="external">developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators</a></cite></footer></blockquote><br>At that moment execution flow will get back to example code and, because an error was handled with try-catch, it will be logged in console. Example will continue execution until it will either reach the end of generator or face a new <code>yield</code>:<br><figure class="highlight js"><figcaption><span>example.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = read(<span class="string">'index.js'</span>, <span class="string">'utf8'</span>);</span><br><span class="line"><span class="keyword">var</span> b = request(<span class="string">'http://google.ca'</span>);</span><br><span class="line"><span class="keyword">var</span> res = <span class="keyword">yield</span> [a, b];</span><br></pre></td></tr></table></figure></p> <p>So result of calling <code>gen.throw</code> in <code>onRejected</code> returns an array with a and b:<br><figure class="highlight js"><figcaption><span>co/index.js:onRejected</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ret;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  ret = &#123;value: [a, b], done: <span class="literal">false</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p> <p>Catch brunch is skipped but it would otherwise reject the promise. Finally, another <code>next</code> call happens: it would skip immediate resolve, convert array to a promise created with Promise.all (check out <code>arrayToPromise</code> function), which will be settled only when <code>a</code> and <code>b</code> promises are settled or one of them is rejected. Note how <code>arrayToPromise</code> is making sure that Promise.all argument is an array of promises:<br><figure class="highlight js"><figcaption><span>co/index.js:arrayToPromise</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.map(toPromise, <span class="keyword">this</span>)</span><br></pre></td></tr></table></figure></p> <p><code>toPromise</code> will first check if value is not falsy and if it is, it returns a value:<br><figure class="highlight js"><figcaption><span>co/index.js:toPromise</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!obj) <span class="keyword">return</span> obj;</span><br></pre></td></tr></table></figure></p> <p>If value is a promise already, toPromise will return it:<br><figure class="highlight js"><figcaption><span>co/index.js:toPromise</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isPromise(obj)) <span class="keyword">return</span> obj;</span><br></pre></td></tr></table></figure></p> <p>If value is a generator or a generator function, toPromise will recursively call co, pass it a context and an obj and as a result we will get a new promise:<br><figure class="highlight js"><figcaption><span>co/index.js:toPromise</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isGeneratorFunction(obj) || isGenerator(obj)) <span class="keyword">return</span> co.call(<span class="keyword">this</span>, obj);</span><br></pre></td></tr></table></figure></p> <p>If <code>obj</code> is a function, toPromise will wrap it in a promise. First argument in a function is assumed to be an error object (node.js error handling pattern, so all node js callback APIs are covered):<br><figure class="highlight js"><figcaption><span>co/index.js:toPromise</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">'function'</span> == <span class="keyword">typeof</span> obj) <span class="keyword">return</span> thunkToPromise.call(<span class="keyword">this</span>, obj);</span><br></pre></td></tr></table></figure></p> <p>If <code>obj</code> is an array or an object with <a href="https://github.com/tj/co#yieldables" target="_blank" rel="external">yieldable</a> properties, co will recursively convert them to promises:<br><figure class="highlight js"><figcaption><span>co/index.js:toPromise</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(obj)) <span class="keyword">return</span> arrayToPromise.call(<span class="keyword">this</span>, obj);</span><br><span class="line"><span class="keyword">if</span> (isObject(obj)) <span class="keyword">return</span> objectToPromise.call(<span class="keyword">this</span>, obj);</span><br></pre></td></tr></table></figure></p> <p>So co ensures that <code>a</code> and <code>b</code> are converted to promises, and when both promises are fulfilled - Promise.all will ensure that results are assigned to appropriate indexes in an array. If one of them is rejected, then <code>.catch</code> callback from the example will be able to handle an error (log it somewhere, or re-try once again). In either scenario a new Promise (one returned from co at the very beginning) will be settled, code will be executed asynchronously, and in the manner expected by developer, and will have all benefits of central place for error handling.</p> <p>In a nutshell this is exactly what happens in co: generators and promises take care of asynchronous operations and error handling, while keeping your code clean and easy to follow. Similar logic will be hidden behind a native support of async programming with <a href="https://www.youtube.com/watch?v=DqMFX91ToLw" target="_blank" rel="external">ES7 async-await</a>. If you want to use co, generators and Promises in non ES6 environments, try out 6to5 transpiler (links below).</p> <p>Thank you and please feel free to ask questions in the comments, follow us on <a href="https://www.facebook.com/webuniverseio" target="_blank" rel="external">facebook</a> and <a href="https://twitter.com/webuniverseio" target="_blank" rel="external">twitter</a> pages, or subscribe to our <a href="/atom.xml">feed</a>.</p> <h2 id="Links">Links</h2><ul> <li>co - <a href="https://github.com/tj/co" target="_blank" rel="external">https://github.com/tj/co</a> </li> <li>shallow code - <a href="http://exponential.io/blog/unnest-callbacks/" target="_blank" rel="external">http://exponential.io/blog/unnest-callbacks/</a></li> <li>6to5 transpiler (babeljs) - <a href="https://babeljs.io/docs/learn-es6/" target="_blank" rel="external">https://babeljs.io/docs/learn-es6/</a></li> </ul> <h3 id="Promises">Promises<a name="promises"></a></h3><ul> <li>description - <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="external">https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise</a></li> <li>support - <a href="http://kangax.github.io/compat-table/es6/#Promise" target="_blank" rel="external">http://kangax.github.io/compat-table/es6/#Promise</a></li> <li>examples - <a href="http://www.2ality.com/2014/09/es6-promises-foundations.html" target="_blank" rel="external">http://www.2ality.com/2014/09/es6-promises-foundations.html</a></li> </ul> <h3 id="Generators">Generators<a name="generators"></a></h3><ul> <li>description and examples - <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*</a></li> <li>support - <a href="http://kangax.github.io/compat-table/es6/#generators" target="_blank" rel="external">http://kangax.github.io/compat-table/es6/#generators</a></li> </ul> <style>.article__title{font-size:1.72rem}</style><div id="disqus_thread"></div> </article> </div> <script>var disqus_shortname="webuniverse";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}();</script></main><footer id="page__footer" role="contentinfo"> All content, unless otherwise indicated, <span class="nowrap"> is licensed under <a href="http://creativecommons.org/licenses/by/4.0/" target="_blank" rel="license">CC BY 4.0</a>. </span><br> <span itemscope itemtype="http://schema.org/Person" itemprop="author"> <a href="/about" itemprop="url"> <span itemprop="name">Sergey Zarouski</span></a> </span> &copy; <span itemprop="copyrightYear">2015</span>. </footer> </div> </div> </div> </div> <script>window.WebFontConfig={google:{families:["Slabo+27px"]}},function(){var t=document.createElement("script");t.src=("https:"==document.location.protocol?"https":"http")+"://ajax.googleapis.com/ajax/libs/webfont/1.5.10/webfont.js",t.type="text/javascript",t.async="true";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(t,e)}();</script><script src="/bower_components/picturefill/dist/picturefill.min.js" async></script><script>!function(){var t="014578715170147478038:jt5g2str_f0",e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src=("https:"==document.location.protocol?"https:":"http:")+"//www.google.com/cse/cse.js?cx="+t;var c=document.getElementsByTagName("script")[0];c.parentNode.insertBefore(e,c)}();</script><script>!function(e,n,a,t,o,c,s){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,c=n.createElement(a),s=n.getElementsByTagName(a)[0],c.async=1,c.src=t,s.parentNode.insertBefore(c,s)}(window,document,"script","//www.google-analytics.com/analytics.js","ga"),window.ga("create","UA-57969778-1","auto"),window.ga("send","pageview");</script><noscript><div class="noscript"> Javascript is disabled for this site in your browser. Please enable it if you want to see site in more interactive mode. To learn how click <a class="noscript-text--alternative" href="http://www.youtube.com/watch?v=0w8wr8a0r2M" target="_blank">here</a> or <a class="noscript-text--alternative" href="http://www.google.ca/search?q=how+to+enable+javascript&amp;tbs=vid:1" target="_blank">here</a>. </div></noscript> </body> 