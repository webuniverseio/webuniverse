{"data":{"mdx":{"fileAbsolutePath":"/c/Users/Sergey/dev/webuniverse/src/content/posts/cyclomatic-complexity-refactoring-tips/index.mdx","code":{"body":"function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nconst layoutProps = {};\nreturn class MDXContent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.layout = null;\n  }\n\n  render() {\n    const _this$props = this.props,\n          {\n      components\n    } = _this$props,\n          props = _objectWithoutProperties(_this$props, [\"components\"]);\n\n    return React.createElement(MDXTag, {\n      name: \"wrapper\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `This article briefly explains what is cyclomatic complexity and gives practical tips about how to make your projects maintainable.`), React.createElement(MDXTag, {\n      name: \"h2\",\n      components: components\n    }, `Cyclomatic complexity`), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `In short cyclomatic complexity is a number which indicates how many execution scenarios there might be inside your code. Everyday developers read lots of code and during this process they try to imagine what the code is doing. The more execution scenarios they see in the code, the harder it is to keep track of what is going on. That leads to misunderstanding and therefore to hacks and buggy implementations. Conditional operators increase cyclomatic complexity, so it is a matter of keeping them under control. Following operators will increase cyclomatic complexity in javascript:`), React.createElement(MDXTag, {\n      name: \"pre\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"code\",\n      components: components,\n      parentName: \"pre\",\n      props: {\n        \"className\": \"language-js\"\n      }\n    }, `if | while | for | case | || | catch | ternary operator ?:\n`)), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `Below is an example of how you don't want your code to look as it will be too complex to understand:`), React.createElement(MDXTag, {\n      name: \"pre\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"code\",\n      components: components,\n      parentName: \"pre\",\n      props: {\n        \"className\": \"language-js\"\n      }\n    }, `if (condition) {\n  if (condition) {\n    while (condition ? expression : expression) {\n      if (condition || condition && condition) {\n      }\n    }\n  }\n  //... a few more conditions like this and there is a 100% chance that we'll need a debugger today\n}\n`)), React.createElement(MDXTag, {\n      name: \"h2\",\n      components: components\n    }, `Functions as a way to reduce complexity`), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `We break down code into functions not only to make sure that we don't repeat ourselves, but also to define a scoped scenario which we can understand more easily. If code inside function was written without side effects (does only one thing and exactly what it says it does - that is what we're expecting from APIs which does not belong to us, right? :)), it is enough for us take a look at function's name to get the idea about what it is doing.`), React.createElement(MDXTag, {\n      name: \"pre\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"code\",\n      components: components,\n      parentName: \"pre\",\n      props: {\n        \"className\": \"language-js\"\n      }\n    }, `function run() {\n  if (!isInstalled()) {\n    chooseInstallProcess();\n  }\n}\nfunction isInstalled() {}\nfunction chooseInstallProcess() {\n  if (shouldSkipDownload()) {\n    installProgram();\n  } else {\n    downloadAndInstall();\n  }\n}\nfunction shouldSkipDownload() {}\nfunction downloadAndInstall() {\n  downloadProgram();\n  installProgram();\n}\nfunction downloadProgram() {}\nfunction installProgram() {}\n`)), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `It is much easier to read code which is broken into smaller functions, isn't it? Small functions alone will improve readability of your code and make whole app much more stable and maintainable. `, React.createElement(MDXTag, {\n      name: \"strong\",\n      components: components,\n      parentName: \"p\"\n    }, `When we split code into functions we split cyclomatic complexity.`)), React.createElement(MDXTag, {\n      name: \"h2\",\n      components: components\n    }, `Tools`), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `Code analysis tools like `, React.createElement(MDXTag, {\n      name: \"a\",\n      components: components,\n      parentName: \"p\",\n      props: {\n        \"href\": \"http://eslint.org/docs/rules/complexity.html\"\n      }\n    }, `eslint`), ` or `, React.createElement(MDXTag, {\n      name: \"a\",\n      components: components,\n      parentName: \"p\",\n      props: {\n        \"href\": \"http://jshint.com/docs/options/#maxcomplexity\"\n      }\n    }, `jshint`), ` will help you to find the value of cyclomatic complexity per each function. All you need to do is to define a max value after which they'll start logging errors. My personal preference for max complexity is 3 as it will guarantee that my functions will be small. Code below will fail complexity check:`), React.createElement(MDXTag, {\n      name: \"pre\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"code\",\n      components: components,\n      parentName: \"pre\",\n      props: {\n        \"className\": \"language-js\"\n      }\n    }, `function getName(firstName, lastName) {\n  //cyclomatic complexity always starts from 1\n  if (firstName && lastName) { //if operator, +1\n    return firstName + ' ' + lastName;\n  } else if (firstName) { // +1\n    return firstName;\n  } else if (lastName) { // +1\n    return lastName;\n  } else if (!firstName && !lastName) { // +1\n    return 'stranger';\n  }\n  //total complexity is 5\n}\n`)), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `And following code will pass:`), React.createElement(MDXTag, {\n      name: \"pre\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"code\",\n      components: components,\n      parentName: \"pre\",\n      props: {\n        \"className\": \"language-js\"\n      }\n    }, `function getNameOrFallback(name, fallback) {\n  //complexity starts from 1\n  return name || fallback; //|| operator, +1\n  //total complexity is 2\n}\n\nfunction getName(firstName, lastName) {\n  //complexity starts from 1\n  let name = '';\n  if (firstName) { //if operator, +1\n    name = firstName;\n  }\n  if (lastName) { // +1\n    name += ' ' + lastName;\n  }\n  //even though complexity for getNameOrFallback is 2, it doesn't add up to complexity of current function\n  return getNameOrFallback(name.trim(), 'stranger');\n  //total complexity is 3\n}\n`)), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `When max complexity is set to 3 we can use at least two `, React.createElement(MDXTag, {\n      name: \"inlineCode\",\n      components: components,\n      parentName: \"p\"\n    }, `if`), ` operators, which is more than enough per function. Every time, when you run into situation, where you need complexity to be more than 3 - you need to refactor, move part of the logic into a separate function or both.`), React.createElement(MDXTag, {\n      name: \"h2\",\n      components: components\n    }, `Refactoring tips`), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `There are a few scenarios where you might be tempted to disable or increase max-complexity. It is always a bad decision, so let me show you a few examples and how code can be refactored to meet your standards.`), React.createElement(MDXTag, {\n      name: \"h3\",\n      components: components\n    }, `Refactoring a switch-like logic`), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `Following example can be arbitrary complex:`), React.createElement(MDXTag, {\n      name: \"pre\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"code\",\n      components: components,\n      parentName: \"pre\",\n      props: {\n        \"className\": \"language-js\"\n      }\n    }, `function getMarkupForError(error) {\n  switch (error) {\n  case 'validation-error':\n    //...\n    break;\n  case 'network-error':\n    //...\n    break;\n  case 'server-error':\n    //...\n    break;\n  //... more cases\n  default:\n    //...handle unknown error\n    break;\n  }\n  //arbitrary complex\n}\n`)), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `The same example also can be re-written with if/if-else/else operators:`), React.createElement(MDXTag, {\n      name: \"pre\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"code\",\n      components: components,\n      parentName: \"pre\",\n      props: {\n        \"className\": \"language-js\"\n      }\n    }, `function getMarkupForError(error) {\n  if (error === 'validation-error') {/*...*/}\n  else if (error === 'network-error') {/*...*/}\n  else if (error === 'server-error') {/*...*/}\n  //...more conditions\n  else {/*...handle unknown error*/}\n  //arbitrary complex\n}\n`)), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `In order to reduce complexity here you simply need to create a map object:`), React.createElement(MDXTag, {\n      name: \"pre\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"code\",\n      components: components,\n      parentName: \"pre\",\n      props: {\n        \"className\": \"language-js\"\n      }\n    }, `function getMarkupForError(error) {\n  let errorTypeToMarkupMap = {\n    'validation-error': function () {/*...*/},\n    'network-error': function () {/*...*/},\n    'server-error': function () {/*...*/}\n  };\n  if (errorTypeToMarkupMap.hasOwnProperty(error)) {\n    return errorTypeToMarkupMap[error];\n  }\n  /*...handle unknown error*/\n  //total complexity of this function will be 2\n}\n`)), React.createElement(MDXTag, {\n      name: \"h3\",\n      components: components\n    }, `Refactoring logic which follows a pattern`), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `Following example is a bit more complex so we can't use switch:`), React.createElement(MDXTag, {\n      name: \"pre\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"code\",\n      components: components,\n      parentName: \"pre\",\n      props: {\n        \"className\": \"language-js\"\n      }\n    }, `function highlightCurrentSection(\\$t) {\n  \\$t.find('.menu__item').removeClass('active');\n  let pathname = window.location.pathname;\n  if (/\\/(books|livres)/i.test(pathname)) {\n    \\$t.find('.menu__books').addClass('active');\n  }\n  else if (/\\/(baby|bebe)/i.test(pathname)) {\n    \\$t.find('.menu__baby').addClass('active');\n  }\n  else if (/\\/(house-and-home|maison)/i.test(pathname)) {\n    \\$t.find('.menu__houseandhome').addClass('active');\n  }\n  //...more conditions\n  else if (/\\/giftcards/i.test(pathname)) {\n    \\$t.find('.menu__giftcards').addClass('active');\n  }\n  //arbitrary complex\n}\n`)), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `We can see that branches are following a pattern - we check that regex is matching current location and add an `, React.createElement(MDXTag, {\n      name: \"inlineCode\",\n      components: components,\n      parentName: \"p\"\n    }, `active`), ` class to specified selector. The same code can be simplified if we create an array of objects, which contain a pattern and a selector and loop through it:`), React.createElement(MDXTag, {\n      name: \"pre\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"code\",\n      components: components,\n      parentName: \"pre\",\n      props: {\n        \"className\": \"language-js\"\n      }\n    }, `function highlightCurrentSection(\\$t) {\n  \\$t.find('.menu__item').removeClass('active');\n\n  let menuItems = [\n    {pattern: /\\/(books|livres)/i, className: '.menu__books'},\n    {pattern: /\\/(baby|bebe)/i, className: '.menu__baby'},\n    {pattern: /\\/(house-and-home|maison)/i, className: '.menu__houseandhome'},\n    {pattern: /\\/giftcards/i, className: '.menu__giftcards'}\n  ];\n  let hasMatch = false;\n  let pathname = window.location.pathname;\n  _.each(menuItems, function addClassIfNeeded(params) {\n    if(!hasMatch && params.pattern.test(pathname)) {\n      \\$t.find(params.className).addClass('active');\n      hasMatch = true;\n    }\n    //total complexity of addClassIfNeeded is 2\n  });\n  //total complexity of highlightCurrentSection function is 1\n}\n`)), React.createElement(MDXTag, {\n      name: \"h3\",\n      components: components\n    }, `Refactoring logic where branches have similar purpose`), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `In following example we can see that branches inside lookupModule have the same purpose, but code inside conditions and inside branches doesn't follow a pattern:`), React.createElement(MDXTag, {\n      name: \"pre\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"code\",\n      components: components,\n      parentName: \"pre\",\n      props: {\n        \"className\": \"language-js\"\n      }\n    }, `function lookupModule(id) {\n  let sharedPathsConfig = require('../sharedPathsConfig');\n  let overWritesForServer = 'events';\n  let map = {react: 'react/addons', jquery: overWritesForServer};\n  if (/^\\\\$.+/.test(id)) {\n    return overWritesForServer;\n  }\n  if (map[id]) {\n    return map[id];\n  }\n  if (id in sharedPathsConfig.paths) {\n    return path.join(process.cwd(), sharedPathsConfig.paths[id]);\n  }\n  //...more conditions\n  return id;\n  //total complexity of lookupModule is arbitrary\n}\n`)), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `On order to refactor this we can create an array of objects which contain a callback for condition and a callback for logic and iterate over it:`), React.createElement(MDXTag, {\n      name: \"pre\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"code\",\n      components: components,\n      parentName: \"pre\",\n      props: {\n        \"className\": \"language-js\"\n      }\n    }, `function lookupModule(id) {\n  let sharedPathsConfig = require('../sharedPathsConfig');\n  let overWritesForServer = 'events';\n  let map = {react: 'react/addons', jquery: overWritesForServer};\n  let lookupActions = [\n    {\n      condition: function() {return /^\\\\$.+/.test(id);},\n      result: function() {return overWritesForServer;}\n    },\n    {\n      condition: function() {return map[id];},\n      result: function() {return map[id];}\n    },\n    {\n      condition: function() {return id in sharedPathsConfig.paths;},\n      result: function() {return path.join(process.cwd(), sharedPathsConfig.paths[id]);}\n    },\n    //...more conditions\n    {\n      condition: function() {return true;},\n      result: function() {return id;}\n    }\n  ];\n  //Symbol.iterator is used here for simplicity, you can use a polyfill function \\`makeIterator\\` from\n  //https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators\n  let actionsIterator = lookupActions[Symbol.iterator]();\n  let result;\n  while (!result) {\n    let action = actionsIterator.next().value;\n    if (action.condition()) {\n      result = action.result();\n    }\n  }\n  return result;\n  //total complexity of lookupModule function is 3\n}\n`)), React.createElement(MDXTag, {\n      name: \"h2\",\n      components: components\n    }, `Final thoughts`), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `Cyclomatic complexity defines how many use cases we should keep in mind (and how many tests we need to create) while working with a program. It is important to keep cyclomatic complexity under control and as we could see with a little practice we can keep it low quite easily.`), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `I hope you liked this article. Please share your thoughts an tips in comments.`), React.createElement(MDXTag, {\n      name: \"h2\",\n      components: components\n    }, `Links`), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"a\",\n      components: components,\n      parentName: \"p\",\n      props: {\n        \"href\": \"https://en.wikipedia.org/wiki/Cyclomatic_complexity\"\n      }\n    }, `Cyclomatic complexity`), ` - Wikipedia\n`, React.createElement(MDXTag, {\n      name: \"a\",\n      components: components,\n      parentName: \"p\",\n      props: {\n        \"href\": \"http://eslint.org/docs/user-guide/integrations\"\n      }\n    }, `eslint integrations`), ` with editors and build tools\n`, React.createElement(MDXTag, {\n      name: \"a\",\n      components: components,\n      parentName: \"p\",\n      props: {\n        \"href\": \"http://jshint.com/install/\"\n      }\n    }, `jshint integrations`), ` with editors and build tools`), React.createElement(\"style\", {\n      dangerouslySetInnerHTML: {\n        __html: `\nmain h1[itemprop=\"name\"] {font-size: 32px;}\n@media (max-width: 540px) {\n    main h1[itemprop=\"name\"] {font-size: 25px;}\n}\n`\n      }\n    }));\n  }\n\n}"},"frontmatter":{"title":"Cyclomatic complexity refactoring tips for javascript developers","image":{"publicURL":"/static/image-595e90ec9420ab789dd8b6b12b6ee75d.jpg"},"imageSmall":{"publicURL":"/static/imageSmall-45f01627efbdbc9d5ddfe8921203e478.jpg"},"overview":"Learn how to make your code much easier for reading and writing through management of cyclomatic complexity","copyright":null,"date":"2015-10-23T00:00:00.000Z","dateFormatted":"23 October, 2015"},"fields":{"slug":"/cyclomatic-complexity-refactoring-tips/"}}},"pageContext":{"slug":"/cyclomatic-complexity-refactoring-tips/"}}